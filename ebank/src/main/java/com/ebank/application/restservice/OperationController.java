package com.ebank.application.restservice;

import com.ebank.application.managedata.OperationBancaire;
import com.ebank.application.managedata.OperationBancaireData;
import com.ebank.application.managedata.OperationBancaireRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

@Controller // This means that this class is a Controller
@RequestMapping(path="/OperationBancaire") // This means URL's start with /demo (after Application path)
public class OperationController {

    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private OperationBancaireRepository operationRepository;

    @PostMapping(path="/AjouterUneOperation") // Map ONLY POST Requests
    public @ResponseBody String addOperation (@RequestParam String libelle , @RequestParam String dateOperation, @RequestParam double montantDebit,  @RequestParam double montantCredit) throws ParseException {
        // @ResponseBody means the returned String is the response, not a view name
        // @RequestParam means it is a parameter from the GET or POST request

        OperationBancaire operationEnCours = new OperationBancaire();

        operationEnCours.setLibelle(libelle);

        SimpleDateFormat formatter = new SimpleDateFormat("yyyyMMdd");
        Date dateOfOperation = formatter.parse(dateOperation);

        operationEnCours.setDateOperation(dateOfOperation);
        operationEnCours.setMontantDebit(montantDebit);
        operationEnCours.setMontantCredit(montantCredit);

        operationRepository.save(operationEnCours);
        return "Operation sauvegarder avec succès !";
    }

    @PostMapping(path="/AjouterListeOperation") // Map ONLY POST Requests
    public @ResponseBody String addOperation (@RequestParam String JSONListOfOperation) throws ParseException, JsonProcessingException {

        // ATTENTION !!!! l'encodage est nécessaire sinon côté API lorsque je transforme de nouveau mon JSON en object,
        // j'obtiens une erreur de jackson car le JSON perd des balises fermantes apparemment
        // problème de décodage
        byte[] decodedParameter = Base64.getDecoder().decode(JSONListOfOperation);

        String listOfOperation = new String(decodedParameter);

        ObjectMapper mapper = new ObjectMapper();

        // Je doit passer par un tableau sinon j'ai le problème suivant avec une liste : (tiré de stackOverflow
        // The issue's coming from Jackson. When it doesn't have enough information on what class to deserialize to, it uses LinkedHashMap.
        // Je me retrouve donc avec un LinkedHashMap ou les clés sont les nom des rubriques et je ne peux pas parcourir ma liste d'objet correctement
        OperationBancaireData[] arrayOperationBancaire = mapper.readValue(listOfOperation, OperationBancaireData[].class);

        // Je convertis par la suite mon tableau en liste d'opération
        List<OperationBancaireData> listBankOperation = Arrays.asList(arrayOperationBancaire);

        // Je dois passer par OperationBancaireData qui a une date en String pour pouvoir la convertir sinon jackson me
        // renvoi une date en 1970 lorsque
        for (OperationBancaireData anOperation : listBankOperation) {
            OperationBancaire bankOperationActual = new OperationBancaire();

            bankOperationActual.setLibelle(anOperation.libelle());
            bankOperationActual.setDateOperation(anOperation.dateOperation());

            bankOperationActual.setMontantCredit(anOperation.montantCredit());
            bankOperationActual.setMontantDebit(anOperation.montantDebit());
            operationRepository.save(bankOperationActual);
        }

        return "Operation sauvegarder avec succès !";
    }

    @GetMapping(path="/RecupererOperationsBancaire")
    public @ResponseBody Iterable<OperationBancaire> getAllBankOperation() {
        // This returns a JSON or XML with the users

        return operationRepository.findAll();
    }
}
